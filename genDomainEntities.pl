#!/usr/bin/perl
use Getopt::Long;
GetOptions(\%options,  "domain=s", "regex=s", "command=s", "testcasesDir=s", "regexUsage=s", "insideOccurrences=s", "inputType=s", "insideRegex=s" => \@recognizeRegex, "insideAttribute=s" => \@recognizeValue, "h");
if($options{h}) {
	print "\nUsage: ./singleProblemScript [OPTION]... 
Prints on stdout a set of asp rules representing the following entities in the benchmark tool:
1. testcases
2. testcaseData
2. testcaseExecutionData
3. domain
according to provided parameters.

The following parameters are allowed:

	-testcasesDir=s	indicates the folder containing problem instances. Default: ./instances/
					
	-domain=s			specifies the domain name (aka problem name, e.g. hamiltonianCycle). Defaul: problem

	-command=s		represents the portion of command associated to the domain, it is often an input file for solvers (e.g encoding/encoding.dl). Default: \"\".

	-regex=s			the regular expression used for instances recognition. Using perl groups also allows to match recognized strings to problem regexUsage parameter (e.g. if the instance name looks like \"01-hamiltonianCycle.dl\" we can provide \"^[0-9]+-(\\w+)\") as a valid option to recognize instance files, being carefull to use the escape character \"\\\" when needed). Parameter matchings are built in conjunction with the -regexUsage option.

	-regexUsage=s		e.g.: \"solver1:-n=,solver2:--maxint=\"
						it specifies how to use groups generated by \"regex\" parameter. Eventually creating some testcaseExecution data atoms in order to pass parameters to solvers.
						
	-insideRegex=s[]
	-insideAttribute=s[]	the first option adds a regex to an ordered set of expressions. The second option adds a keyword to a set of key-values.
						Those sets must have the same cardinality. Then, all regular expression are processed. They must contain a single perl group. The first value recognized by the regex in every instance file will be matched to the next key in the second set, generating a corresponding testcaseData new atom.
	e.g: insideRegex=\"dimension([0-9]+)\" recognizeValue=\"dimension\" -> the first occurrence of the regex will generate a perl group and the value will be matched with the key \"dimension\".

	-insideOccurrences=s[]
						it will add a testcaseData containing the parameter specified as key and the number of occurrences of the key in the instance file as value. e.g.: insideOccurrences=\"edge\"

\n";
	
	exit;
}

$inputType = $options{inputType} || "fileInput";
$domainPrefix = "";
$domainSuffix = "";
if($inputType eq "stdin") {
	$domainPrefix = " < ";
}
elsif($inputType eq "stdinInstances") {
	$domainSuffix = " < ";
}

$instancesFolder = $options{testcasesDir} || "./instances";
print "instancesFolder(\"$instancesFolder\").\n";
$insideOccurrences = $options{insideOccurrences};
$domain = $options{domain} || "problem";
$domainCommand = $options{command} || "";
$domainCommand = $domainPrefix.$domainCommand.$domainSuffix;
$regexUsage = $options{regexUsage} || "";
@regexUsageSplit = split(" ",$regexUsage);
$regex = $options{regex} || "^";

@instances = qx (ls -B $instancesFolder);
for($j=0;$j<scalar(@regexUsageSplit);$j++) {
	$splitMap{$regexUsageSplit[$j]} = $j;
	if($regexUsageSplit[$j] eq "Id") {
		$idIsSet = 1;
	}
}

$idPos = $splitMap{Id};
$progressive =0;
foreach $file (@instances) {
	$progressive++;
	chomp $file;
	if(@matches  = $file =~ m/$regex/) {
		
		if(!$idIsSet) {
			$id=$progressive;
		}
		else {
			$id = $matches[$idPos];
		}
		for $key (keys(%splitMap)) {
			if($key =~ m/^K(\d+)/) {
				print "testcaseData($id,$domain,$matches[$splitMap{$key}],$matches[$splitMap{V.$1}]).\n";
			}
			elsif($key ne "Id" && !($key =~ m/^V(\d+)/)) {
				if($key =~ m/:/) {					
					@solversParSplit = split ( "," ,$key);
					for $solverSingleSplit(@solversParSplit) {
						if($solverSingleSplit =~ m/(\w+):([\w+\=\-]+)/) {
							print "testcaseExecutionData($1,$id,$domain,\"$2\",\"$matches[$splitMap{$key}]\").\n";		
						}				
					}
						
				}
				else {
					print "testcaseData($id,$domain,$key,$matches[$splitMap{$key}]).\n";
				}
			}
		}
		print "testcase($id,$domain, \"$instancesFolder/$file\").\n";
	}
	if($insideOccurrences) {
		open FILE, "$instancesFolder/$file";
		@lines = <FILE>;
		@occurrencesSplit = split(" ",$insideOccurrences);
		foreach $data (@occurrencesSplit) {	
			$counter = 0;					
			for $line (@lines) {	
				@split = split $data ,$line;
				$counter+= scalar(@split-1);								
			}	
			print "testcaseData($progressive,$domain,$data,$counter).\n";	
		}
		close FILE;
	}
	if(@recognizeRegex) {
		if(scalar(@recognizeRegex)!=scalar(@recognizeValue)) {
			print "recognizeRegex and recognizeValue must have the same length\n";
			die;
		}
		open FILE, "$instancesFolder/$file";
		@lines = <FILE>;
		
		foreach $line (@lines) {
			for($i=0;$i<scalar(@recognizeRegex);$i++) {
				if($line =~ m/$recognizeRegex[$i]/) {
					print "testcaseData($progressive,$domain,$recognizeValue[$i],$1).\n";						
				}
				last;	
			}		
		}	
		close FILE;	
	}
}
chomp  $domainCommand;
print "domain($domain, \"$domainCommand\").\n";
